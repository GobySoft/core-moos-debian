--- a/Essentials/MOOSUtilityLib/CMakeLists.txt
+++ b/Essentials/MOOSUtilityLib/CMakeLists.txt
@@ -22,7 +22,7 @@
 
 
 
-ADD_LIBRARY(MOOSUtility ${MOOSUTILITYLIB_SRCS})
+ADD_LIBRARY(MOOSUtility SHARED ${MOOSUTILITYLIB_SRCS})
 
 SET(INSTALL_HEADERS
    MOOSTerrain.h
@@ -39,6 +39,8 @@
    MOOSMemoryMapped.h
 )
 
+TARGET_LINK_LIBRARIES(MOOSUtility proj MOOS MOOSGen)
+
 # install headers
 INSTALL( FILES ${INSTALL_HEADERS} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/MOOSUtilityLib )
 
--- a/Essentials/MOOSUtilityLib/MOOSGeodesy.cpp
+++ b/Essentials/MOOSUtilityLib/MOOSGeodesy.cpp
@@ -36,6 +36,13 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <cstring>
+#include <cmath>
+#include <string>
+#include <sstream>
+#include <iostream>
+#include <limits>
+
+
 
 #ifdef _WIN32
 #include <float.h>
@@ -44,6 +51,9 @@
 
 
 
+
+
+
 /*Reference ellipsoids derived from Peter H. Dana's website- 
 http://www.utexas.edu/depts/grg/gcraft/notes/datum/elist.html
 Department of Geography, University of Texas at Austin
@@ -59,7 +69,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CMOOSGeodesy::CMOOSGeodesy()
+CMOOSGeodesy::CMOOSGeodesy() : pj_utm_(0),
+                               pj_latlong_(0)
 {
     //create the variables by Zeroing
     SetMetersNorth(0.0);
@@ -85,7 +96,8 @@
 
 CMOOSGeodesy::~CMOOSGeodesy()
 {
-
+    pj_free(pj_utm_);
+    pj_free(pj_latlong_);
 }
 
 /**
@@ -112,22 +124,38 @@
     SetOriginLatitude(lat);
     SetOriginLongitude(lon);
 
+    int zone = (static_cast<int>(std::floor((lon + 180)/6)) + 1) % 60;
+
+    std::stringstream proj_utm;
+    proj_utm << "+proj=utm +ellps=WGS84 +zone=" << zone;
+
+    if (!(pj_utm_ = pj_init_plus(proj_utm.str().c_str())))
+    {
+        std::cerr << "Failed to initiate utm proj" << std::endl;
+        return false;
+    }
+    if (!(pj_latlong_ = pj_init_plus("+proj=latlong +ellps=WGS84")) )
+    {
+        std::cerr << "Failed to initiate latlong proj" << std::endl;
+        return false;
+    }
+
     //Translate the Origin coordinates into Northings and Eastings 
-    double tempNorth = 0.0, tempEast = 0.0;
-    char utmZone[4];
-    LLtoUTM(m_iRefEllipsoid, m_dOriginLatitude, 
-            m_dOriginLongitude, tempNorth, 
-            tempEast, utmZone);
+    double tempNorth = lat*DEG_TO_RAD,
+        tempEast = lon*DEG_TO_RAD;
+
+    int err;
+    if(err = pj_transform(pj_latlong_, pj_utm_, 1, 1, &tempEast, &tempNorth, NULL))
+    {
+        std::cerr << "Failed to transform datum, reason: " << pj_strerrno(err) << std::endl;
+        return false;
+    }
 
     //Then set the Origin for the Northing/Easting coordinate frame
     //Also make a note of the UTM Zone we are operating in
     SetOriginNorthing(tempNorth);
     SetOriginEasting(tempEast);
-    SetUTMZone(utmZone);
-
-    //We set this flag to indicate that the first calculation of distance
-    //traveled is with respect to the origin coordinates.
-    m_bSTEP_AFTER_INIT = true;
+    SetUTMZone(zone);
 
     return true;
 }
@@ -163,111 +191,6 @@
     return m_dEast;
 }
 
-
-bool CMOOSGeodesy::LLtoUTM(int ReferenceEllipsoid, const double Lat, 
-                            const double Long, double &UTMNorthing, 
-                            double &UTMEasting, char *UTMZone)
-{
-    //converts lat/long to UTM coords.  Equations from USGS Bulletin 1532 
-    //East Longitudes are positive, West longitudes are negative. 
-    //North latitudes are positive, South latitudes are negative
-    //Lat and Long are in decimal degrees
-    //Written by Chuck Gantz- chuck.gantz@globalstar.com
-
-    double a = ellipsoid[ReferenceEllipsoid].EquatorialRadius;
-    double eccSquared = ellipsoid[ReferenceEllipsoid].eccentricitySquared;
-    double k0 = 0.9996;
-
-    double LongOrigin;
-    double eccPrimeSquared;
-    double N, T, C, A, M;
-    
-    //Make sure the longitude is between -180.00 .. 179.9
-    double LongTemp = (Long+180)-int((Long+180)/360)*360-180; // -180.00 .. 179.9;
-
-    double LatRad = Lat*deg2rad;
-    double LongRad = LongTemp*deg2rad;
-    double LongOriginRad;
-    int    ZoneNumber;
-
-    ZoneNumber = int((LongTemp + 180)/6) + 1;
-  
-    if( Lat >= 56.0 && Lat < 64.0 && LongTemp >= 3.0 && LongTemp < 12.0 )
-        ZoneNumber = 32;
-
-    // Special zones for Svalbard
-    if( Lat >= 72.0 && Lat < 84.0 ) 
-    {
-      if(      LongTemp >= 0.0  && LongTemp <  9.0 ) ZoneNumber = 31;
-      else if( LongTemp >= 9.0  && LongTemp < 21.0 ) ZoneNumber = 33;
-      else if( LongTemp >= 21.0 && LongTemp < 33.0 ) ZoneNumber = 35;
-      else if( LongTemp >= 33.0 && LongTemp < 42.0 ) ZoneNumber = 37;
-     }
-    LongOrigin = (ZoneNumber - 1)*6 - 180 + 3;  //+3 puts origin in middle of zone
-    LongOriginRad = LongOrigin * deg2rad;
-
-    //compute the UTM Zone from the latitude and longitude
-    if(UTMZone) // mikerb
-      sprintf(UTMZone, "%d%c", ZoneNumber, UTMLetterDesignator(Lat));
-
-    eccPrimeSquared = (eccSquared)/(1-eccSquared);
-
-    N = a/sqrt(1-eccSquared*sin(LatRad)*sin(LatRad));
-    T = tan(LatRad)*tan(LatRad);
-    C = eccPrimeSquared*cos(LatRad)*cos(LatRad);
-    A = cos(LatRad)*(LongRad-LongOriginRad);
-
-    M = a*((1    - eccSquared/4        - 3*eccSquared*eccSquared/64    - 5*eccSquared*eccSquared*eccSquared/256)*LatRad 
-                - (3*eccSquared/8    + 3*eccSquared*eccSquared/32    + 45*eccSquared*eccSquared*eccSquared/1024)*sin(2*LatRad)
-                                    + (15*eccSquared*eccSquared/256 + 45*eccSquared*eccSquared*eccSquared/1024)*sin(4*LatRad) 
-                                    - (35*eccSquared*eccSquared*eccSquared/3072)*sin(6*LatRad));
-    
-    UTMEasting = (double)(k0*N*(A+(1-T+C)*A*A*A/6
-                    + (5-18*T+T*T+72*C-58*eccPrimeSquared)*A*A*A*A*A/120)
-                    + 500000.0);
-
-    UTMNorthing = (double)(k0*(M+N*tan(LatRad)*(A*A/2+(5-T+9*C+4*C*C)*A*A*A*A/24
-                 + (61-58*T+T*T+600*C-330*eccPrimeSquared)*A*A*A*A*A*A/720)));
-    if(Lat < 0)
-        UTMNorthing += 10000000.0; //10000000 meter offset for southern hemisphere
-
-    return true;
-}
-
-
-
-char CMOOSGeodesy::UTMLetterDesignator(double Lat)
-{
-    //This routine determines the correct UTM letter designator for the given latitude
-    //returns 'Z' if latitude is outside the UTM limits of 84N to 80S
-    //Written by Chuck Gantz- chuck.gantz@globalstar.com
-    char LetterDesignator;
-
-    if((84 >= Lat) && (Lat >= 72)) LetterDesignator = 'X';
-    else if((72 > Lat) && (Lat >= 64)) LetterDesignator = 'W';
-    else if((64 > Lat) && (Lat >= 56)) LetterDesignator = 'V';
-    else if((56 > Lat) && (Lat >= 48)) LetterDesignator = 'U';
-    else if((48 > Lat) && (Lat >= 40)) LetterDesignator = 'T';
-    else if((40 > Lat) && (Lat >= 32)) LetterDesignator = 'S';
-    else if((32 > Lat) && (Lat >= 24)) LetterDesignator = 'R';
-    else if((24 > Lat) && (Lat >= 16)) LetterDesignator = 'Q';
-    else if((16 > Lat) && (Lat >= 8)) LetterDesignator = 'P';
-    else if(( 8 > Lat) && (Lat >= 0)) LetterDesignator = 'N';
-    else if(( 0 > Lat) && (Lat >= -8)) LetterDesignator = 'M';
-    else if((-8> Lat) && (Lat >= -16)) LetterDesignator = 'L';
-    else if((-16 > Lat) && (Lat >= -24)) LetterDesignator = 'K';
-    else if((-24 > Lat) && (Lat >= -32)) LetterDesignator = 'J';
-    else if((-32 > Lat) && (Lat >= -40)) LetterDesignator = 'H';
-    else if((-40 > Lat) && (Lat >= -48)) LetterDesignator = 'G';
-    else if((-48 > Lat) && (Lat >= -56)) LetterDesignator = 'F';
-    else if((-56 > Lat) && (Lat >= -64)) LetterDesignator = 'E';
-    else if((-64 > Lat) && (Lat >= -72)) LetterDesignator = 'D';
-    else if((-72 > Lat) && (Lat >= -80)) LetterDesignator = 'C';
-    else LetterDesignator = 'Z'; //This is here as an error flag to show that the Latitude is outside the UTM limits
-
-    return LetterDesignator;
-}
-
 void CMOOSGeodesy::SetMetersNorth(double North)
 {
     m_dNorth = North;
@@ -298,13 +221,12 @@
     m_iRefEllipsoid = refEllipsoid;
 }
 
-void CMOOSGeodesy::SetUTMZone(const char * utmZone)
+void CMOOSGeodesy::SetUTMZone(int zone)
 {
-    // Better hope the input string is no longer than 4...
-    strcpy(m_sUTMZone, utmZone);
+    m_sUTMZone = zone;
 }
 
-char * CMOOSGeodesy::GetUTMZone()
+int CMOOSGeodesy::GetUTMZone()
 {
     return m_sUTMZone;
 }
@@ -336,44 +258,31 @@
                                     double &MetersNorth,
                                     double &MetersEast)
 {
-    //first turn the lat/lon into UTM
-    double tmpNorth = 0.0, tmpEast = 0.0;
-    double dN = 0.0, dE = 0.0; 
-    char tmpUTM[4];
-
-    // LLtoUTM(m_iRefEllipsoid,lat,lon,tmpNorth,tmpEast,tmpUTM);
-    LLtoUTM(m_iRefEllipsoid,lat,lon,tmpNorth,tmpEast,0); // mikerb
-
-    //could check for the UTMZone differing, and if so, return false
-
-    //If this is the first time through the loop,then
-    //compare the returned Northing & Easting values with the origin.
-    //This does not need to be split like into before and after first reading, but
-    //makes the calculation clearer.  Plus, can add other features like logging
-    //or publishing of value
-    if(m_bSTEP_AFTER_INIT){
-        dN = tmpNorth - GetOriginNorthing();
-        dE = tmpEast - GetOriginEasting();
-        SetMetersNorth(dN);
-        SetMetersEast(dE);
-
-        m_bSTEP_AFTER_INIT = !m_bSTEP_AFTER_INIT;
-    }else{
-        double totalNorth = tmpNorth - GetOriginNorthing();
-        dN = totalNorth - GetMetersNorth();
-        //add the increment to the current North value
-        SetMetersNorth(dN + GetMetersNorth());
-
-        double totalEast = tmpEast - GetOriginEasting();
-        dE = totalEast - GetMetersEast();
-        //add the increment to the current East value
-        SetMetersEast(dE + GetMetersEast());
+    double dN, dE;
+    double tmpEast = lon * DEG_TO_RAD;
+    double tmpNorth = lat * DEG_TO_RAD;
+    MetersNorth = std::numeric_limits<double>::quiet_NaN();
+    MetersEast =  std::numeric_limits<double>::quiet_NaN();
+
+    if(!pj_latlong_ || !pj_utm_)
+    {
+        std::cerr << "Must call Initialise before calling LatLong2LocalUTM" << std::endl;
+        return false;
     }
 
-    //This is the total distance traveled thus far, either North or East
+    int err;
+    if(err = pj_transform(pj_latlong_, pj_utm_, 1, 1, &tmpEast, &tmpNorth, NULL ))
+    {
+        std::cerr << "Failed to transform (lat,lon) = (" << lat << "," << lon << "), reason: " << pj_strerrno(err) << std::endl;
+        return false;
+    }
+
+    dN = tmpNorth - GetOriginNorthing();
+    dE = tmpEast - GetOriginEasting();
+    SetMetersNorth(dN);
+    SetMetersEast(dE);
     MetersNorth = GetMetersNorth();
     MetersEast = GetMetersEast();
-    
     return true;
 }
 
@@ -488,50 +397,27 @@
 
 bool CMOOSGeodesy::UTM2LatLong(double dfX, double dfY, double& dfLat, double& dfLong)
 {
-    //written by Henrik Schmidt henrik@mit.edu
-    
-    double err = 1e20;
-    double dfx=dfX;
-    double dfy=dfY;
-    double eps = 1.0; // accuracy in m
-    
-    while (err > eps)
-    {
-        double dflat, dflon, dfnew_x, dfnew_y ;
+    double x = dfX + GetOriginEasting();
+    double y = dfY + GetOriginNorthing();
 
-        // first guess geodesic
-        if (!LocalGrid2LatLong(dfx,dfy,dflat,dflon))
-            return(false);
-        
-        // now convert latlong to UTM
-        if (!LatLong2LocalUTM(dflat,dflon,dfnew_y,dfnew_x))
-            return(false);
-        
-		// fix to segfault issue if you get diverging values
-		if(isnan(dflat) || isnan(dflon))
-		{
-			dflat = 91;
-			dflon = 181;
-			return(false);
-		}
-		
-        // how different
-        double dfdiff_x = dfnew_x -dfX;
-        double dfdiff_y = dfnew_y -dfY;
-        
-        // subtract difference and reconvert        
-        dfx -= dfdiff_x;
-        dfy -= dfdiff_y;
-        
-        err = hypot(dfnew_x-dfX,dfnew_y-dfY);
-        
-        //MOOSTrace("UTM2LatLong: error = %f\n",err); 
+    dfLat = std::numeric_limits<double>::quiet_NaN();
+    dfLong = std::numeric_limits<double>::quiet_NaN();
+
+    if(!pj_latlong_ || !pj_utm_)
+    {
+        std::cerr << "Must call Initialise before calling UTM2LatLong" << std::endl;
+        return false;
     }
     
-    if (!LocalGrid2LatLong(dfx, dfy, dfLat, dfLong))
-        return(false);
-    
-    
- 	return true;
+    int err;
+    if(err = pj_transform(pj_utm_, pj_latlong_, 1, 1, &x, &y, NULL))
+    {
+        std::cerr << "Failed to transform (x,y) = (" << dfX << "," << dfY << "), reason: " << pj_strerrno(err) << std::endl;
+        return false;
+    }
+
+    dfLat = y * RAD_TO_DEG;
+    dfLong = x * RAD_TO_DEG;
+    return true;
 }
 
--- a/Essentials/MOOSUtilityLib/MOOSGeodesy.h
+++ b/Essentials/MOOSUtilityLib/MOOSGeodesy.h
@@ -42,6 +42,10 @@
     #define  PI 3.14159265
 #endif
 
+// tes@mit.edu - changed UTM to use PROJ4 to fix various bugs in the original
+// implementation
+#include <proj_api.h>
+
 const double FOURTHPI = PI / 4;
 const double deg2rad = PI / 180;
 const double rad2deg = 180.0 / PI;
@@ -62,7 +66,7 @@
     bool 	UTM2LatLong(double dfX, double dfY, double& dfLat, double& dfLong);
     
     
-    char * 	GetUTMZone();
+    int 	GetUTMZone();
     int 	GetRefEllipsoid();
     double 	GetMetersEast();
     double 	GetMetersNorth();
@@ -72,7 +76,7 @@
 
 private:
     bool m_bSTEP_AFTER_INIT;
-    char m_sUTMZone[4];
+    int m_sUTMZone;
     int m_iRefEllipsoid;
     double m_dOriginEasting;
     double m_dOriginNorthing;
@@ -82,13 +86,13 @@
     double m_dOriginLatitude;
     double m_dLocalGridX;
     double m_dLocalGridY;
+    projPJ pj_utm_, pj_latlong_;
 
-    void SetUTMZone(const char * utmZone);
+    void SetUTMZone(int zone);
     void SetRefEllipsoid(int refEllipsoid);
     void SetOriginEasting(double East);
 
     void SetOriginNorthing(double North);
-    bool LLtoUTM(int ReferenceEllipsoid, const double Lat, const double Long, double &UTMNorthing, double &UTMEasting, char* UTMZone=0);
     void SetMetersEast(double East);
     void SetMetersNorth(double North);
     char UTMLetterDesignator(double Lat);
